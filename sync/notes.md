# Заметки по задачам на синхронизацию

## Пункт 2.1

Как и ожидалось, возникают проблемы из-за конкурентного обращения к разделяемому ресурсу - очереди. В исходном варианте программы у меня возникало два типа ошибок:
1. При чтении получаем не то значение, которое ожидалось, затем происходит segfault.
2. Просто происходит segfault.
Возможное объяснение см. в комментариях в коде.
Общее замечание: проблема всегда в том, что операции не атомарны. Работа одной операции прерывается, вместо нее запускается другая, которая вносит изменения в структуру данных. Затем снова включается первая, которая еще "не знает" об изменениях, и вносит свои изменения, что в итоге нарушает внутреннее устройство структуры данных.

Если поставить размер очереди меньше (например, 1000), то ошибок не возникает. Это происходит потому, что поток успевает полностью записать/прочитать очередь прежде чем его переключат. Чем больше размер очереди, тем выше вероятность ошибки.

Если привязывать каждый поток к своему процессу, ошибка возникает почти мнгновенно. Очевидно, что если процессы работают параллельно, вероятность ошибки гораздо больше.

Если убрать `sched_yield()` перед созданием второго потока, особой разницы не наблюдается. Дело в том, что `sched_yield()` предназначен для использования с определенными политиками планирования. При использовании с политикой по умолчанию поведение этой функции не определено.

## Пункт 2.2

### spinlock

Для решения проблем конкуретного доступа используются средства синхронизации. Самый базовый примитив синхронизации - спинлок.
Спинлок представляет собой ячейку в памяти, содержащую 0 или 1. 1 означает, что спинлок занят, 0 - что свободен. Когда поток хочет занять спинлок, он крутится в цикле, читает текущее состояние спинлока и записывает 1. Цикл завершается, когда прочитанное значение равно 0. Это означает, что спинлок был свободен, а теперь захвачен, т.к. поток уже записал 1.

Операции занятия/освобождения спинлока реализуются при помощи атомарных команд процессора. Для операции занятия используется команада xchg \[addr\] val (на архитектуре x86). Эта команда записывает по адресу *addr* значение *val* и возвращает предыдущее значение. В качетсве *addr* передается адрес спинлока, в качестве *val* - всегда 1. Если ранее был записан 0, значит вызывающий поток забрал спинлок себе. В противном случае спинлок остается равным 1, а вызывающий поток попробует занять его снова. Поскольку xchg - это атомарная операция, то состояния гонки не возникает. Подробнее можно прочитать на [Википедии]https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D0%BD-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0

Библиотека POSIX Threads предоставляет набор примитивов синхронизации, в т.ч. спинлок. Для работы с ним используются функции `pthread_spin_init()`, `pthread_spin_lock()`, `pthread_spin_unlock()`. Чтобы для каждого потока посмотреть загрузку процессора и время, проведенное в режиме пользователя/ядра, можно использовать утилиту htop (см. man).

Спинлок работает целиком в пространстве пользователя. Поэтому при всех измерениях получаем 100% user time. Если оба потока работают на одном ядре, то они загружают его поровну на 50% каждый. Если каждый поток работает на своем ядре, то ядра загружаются на 100%.
Спинлок предназначен для коротких блокировок. Иногда бывает быстрее повисеть в холостом цикле, чем обращаться в ядро для блокировки и переключать контекст. В случае длительной блокировки спинлок неэффективно расходует ресурсы процессора.

### mutex

Более сложный примитив - мьютекс. Мьютекс следует воспринимать как абстрактную сущность, с которой можно выполнять набор операций. Реализация мьютекса может быть различной на разных операционных системах, т.к. зависит от API, предоставляемого ОС. В линуксе pthread_mutex реализован через [futex]https://en.wikipedia.org/wiki/Futex

Мьютекс предназначен для длительных блокировок, когда время ожидания значительно превышает затраты на блокировку.

### conditional

Предыдущие два примитива использовались для обеспечения конкурентного доступа. Условная переменная используется для ожидания наступления какого-либо события. Для условной переменной определены две основные операции:
1. Блокировка (`pthread_cond_wait()`) - вызывающий поток блокируется до тех пор, пока его не разблокируют.
2. Разблокировка (`pthread_cond_signal()`) - разблокирует один из потоков, которые заблокированы на данной условной переменной. Есть вариант с разблокировкой сразу всех потоков.
Само событие заключается в истинности какого-то предиката (условия). Например, если размер очереди > 0, то читающий поток может продолжать работу. В противном случае поток блокируется. После разблокировки поток должен снова проверить условие, и если оно не выполняется, заблокироваться снова.
В функцию блокировки так же передается мьютекс, принадлежащий вызывающему потоку. Функция блокировки атомарно освобождает мьютекс и блокирует поток на условной переменной. При успешном завершении функции блокировки мьютекс снова принадлежит вызывающему потоку. Если не использовать мьютекс, то при пробуждении нескольких потоков может возникнуть состояние гонки (ведь предикат у них общий). Кроме того, часто ожидание по условной переменной происходит внутри критической секции, когда поток уже захватил мьютекс. Тогда надо отпустить мьютекс перед тем, как заблокироваться, иначе мы получим deadlock (один поток заблокирован и ждет события, а другой не может сгенерировать это событие, потому что мьютекс занят первым).

В примере с очередью удобно использовать условную переменную, когда очередь пустая или полная. В этом случае продуктивнее будет заблокироваться, а не обращаться к пустой (полной) очереди вхолостую.
