# Заметки по задачам на синхронизацию

## Пункт 2.1

Как и ожидалось, возникают проблемы из-за конкурентного обращения к разделяемому ресурсу - очереди. В исходном варианте программы у меня возникало два типа ошибок:
1. При чтении получаем не то значение, которое ожидалось, затем происходит segfault.
2. Просто происходит segfault.
Возможное объяснение см. в комментариях в коде.
Общее замечание: проблема всегда в том, что операции не атомарны. Работа одной операции прерывается, вместо нее запускается другая, которая вносит изменения в структуру данных. Затем снова включается первая, которая еще "не знает" об изменениях, и вносит свои изменения, что в итоге нарушает внутреннее устройство структуры данных.

Если поставить размер очереди меньше (например, 1000), то ошибок не возникает. Это происходит потому, что поток успевает полностью записать/прочитать очередь прежде чем его переключат. Чем больше размер очереди, тем выше вероятность ошибки.

Если привязывать каждый поток к своему процессу, ошибка возникает почти мнгновенно. Очевидно, что если процессы работают параллельно, вероятность ошибки гораздо больше.

Если убрать `sched_yield()` перед созданием второго потока, особой разницы не наблюдается.
